import { writeFileSync, mkdirSync } from 'fs'
import { join } from 'path'
import { getTopIssues, getCategoryBreakdown, getDetailedCategoryBreakdown } from './grader.js'
import chalk from 'chalk'
import { htmlReporter } from './html-reporter.js'

export async function generateReport(results, grades, outputDir, config = {}) {
  try {
    // Ensure output directory exists
    mkdirSync(outputDir, { recursive: true })

    const formats = config.output?.formats || ['json', 'markdown']

    // Generate JSON report
    if (formats.includes('json')) {
      await generateJSONReport(results, grades, outputDir)
    }

    // Generate Markdown report
    if (formats.includes('markdown')) {
      await generateMarkdownReport(results, grades, outputDir)
    }

    // Generate HTML report
    if (formats.includes('html')) {
      await htmlReporter.generateReport(results, grades, outputDir, config)
    }

    // Generate FIX_REPORT.md if fixes were applied
    if (results.fixResults && results.fixResults.totalFixes > 0) {
      await generateFixReport(results.fixResults, outputDir)
    }

    console.log(chalk.green(`✅ Reports generated in ${outputDir}/`))
  } catch (error) {
    throw new Error(`Failed to generate reports: ${error.message}`)
  }
}

async function generateJSONReport(results, grades, outputDir) {
  const report = {
    metadata: {
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      tool: 'Next.js + MUI Audit Toolkit'
    },
    summary: {
      overallScore: grades.overallScore,
      letterGrade: grades.letterGrade,
      totalFiles: results.summary?.totalFiles || 0,
      totalIssues: grades.totalIssues,
      criticalIssues: grades.criticalIssues,
      categoryScores: grades.categoryScores
    },
    issues: {
      byCategory: getCategoryBreakdown(results),
      bySeverity: results.summary?.issuesBySeverity || {},
      topIssues: getTopIssues(results, 20),
      eslint: results.eslint || {}
    },
    files: results.files,
    manualChecks: {
      responsive: [],
      accessibility: [],
      performance: [],
      notes: []
    }
  }

  const jsonPath = join(outputDir, 'report.json')
  writeFileSync(jsonPath, JSON.stringify(report, null, 2))
}

async function generateMarkdownReport(results, grades, outputDir) {
  const topIssues = getTopIssues(results, 10)
  const categoryBreakdown = getCategoryBreakdown(results)
  const detailedCategoryBreakdown = getDetailedCategoryBreakdown(results)

  const markdown = `# Next.js + MUI Audit Report

## 📊 Executive Summary

**Overall Score:** ${grades.overallScore}/100 (${grades.letterGrade})

**Project Status:** ${getProjectStatus(grades.overallScore)}

**Audit Date:** ${new Date().toLocaleDateString()}

**Total Files Scanned:** ${results.summary?.totalFiles || 0}

**Total Issues Found:** ${grades.totalIssues}

**Critical Issues:** ${grades.criticalIssues}

---

## 🎯 Category Breakdown

${generateCategoryTable(grades.categoryScores)}

---

## 🚨 Top Issues to Fix

${generateTopIssuesTable(topIssues)}

---

## 📁 File-by-File Analysis

${generateFileAnalysis(results.files)}

---

## 🔍 Issue Details by Category

${generateCategoryDetails(detailedCategoryBreakdown)}

---

## 📋 All Files with Issues Summary

${generateAllFilesSummary(results.files)}

---

## 📋 ESLint Analysis

${generateESLintSection(results.eslint)}

---

## 📈 Detailed Metrics & Statistics

${generateDetailedMetrics(results, grades)}

---

## 🎯 Priority Matrix

${generatePriorityMatrix(results)}

---

## 🛠️ How to Fix Issues

${generateFixInstructions()}

---

*Generated by Next.js + MUI Audit Toolkit v1.0.0 By @dev-mhany*
`

  const markdownPath = join(outputDir, 'REPORT.md')
  writeFileSync(markdownPath, markdown)
}

function getProjectStatus(score) {
  if (score >= 90) return '🟢 Excellent - Production Ready'
  if (score >= 80) return '🟡 Good - Minor Issues to Fix'
  if (score >= 70) return '🟠 Fair - Several Issues to Address'
  if (score >= 60) return '🔴 Poor - Major Issues to Fix'
  return '⚫ Critical - Immediate Action Required'
}

function generateCategoryTable(categoryScores) {
  // Safety check for undefined categoryScores
  if (!categoryScores || typeof categoryScores !== 'object') {
    return '⚠️ Category scores not available'
  }

  const categories = [
    { name: 'Next.js Architecture', key: 'nextjs', weight: 14 },
    { name: 'MUI Usage', key: 'mui', weight: 14 },
    { name: 'Accessibility', key: 'accessibility', weight: 8 },
    { name: 'Responsive Design', key: 'responsive', weight: 8 },
    { name: 'Performance', key: 'performance', weight: 8 },
    { name: 'Security', key: 'security', weight: 8 },
    { name: 'Code Quality', key: 'quality', weight: 10 },
    { name: 'Testing', key: 'testing', weight: 6 },
    { name: 'SEO', key: 'seo', weight: 8 },
    { name: 'Image Optimization', key: 'image', weight: 6 },
    { name: 'Modern Practices', key: 'modern', weight: 4 },
    { name: 'PWA Essentials', key: 'pwa', weight: 6 }
  ]

  let table = '| Category | Score | Weight | Status |\n'
  table += '|----------|-------|--------|--------|\n'

  categories.forEach(category => {
    const score = categoryScores[category.key] || 0
    const status = getStatusEmoji(score)
    table += `| ${category.name} | ${score}/100 | ${category.weight} | ${status} |\n`
  })

  return table
}

function generateTopIssuesTable(topIssues) {
  if (topIssues.length === 0) {
    return '✅ No critical issues found!'
  }

  let table = '| File | Line:Col | Category | Severity | Issue |\n'
  table += '|------|----------|----------|----------|-------|\n'

  topIssues.forEach(issue => {
    const severityIcon = getSeverityIcon(issue.severity)
    const location = `${issue.line}:${issue.column}`
    const category = issue.category.charAt(0).toUpperCase() + issue.category.slice(1)
    const severity = issue.severity.charAt(0).toUpperCase() + issue.severity.slice(1)
    const message =
      issue.message.length > 60 ? issue.message.substring(0, 60) + '...' : issue.message

    // Make file path clickable
    const clickableFilePath = `[\`${(issue.file || issue.filePath || '').split('/').pop()}\`](${issue.file || issue.filePath || ''})`
    table += `| ${clickableFilePath} | ${location} | ${category} | ${severityIcon} ${severity} | ${message} |\n`
  })

  return table
}

function generateFileAnalysis(files) {
  if (!files || Object.keys(files).length === 0) {
    return 'No files analyzed.'
  }

  let analysis = '| File | Score | Issues | Critical |\n'
  analysis += '|------|-------|--------|----------|\n'

  Object.values(files).forEach(file => {
    const status = getScoreIcon(file.score)
    const criticalCount =
      file.issues && Array.isArray(file.issues)
        ? file.issues.filter(i => i.severity === 'error').length
        : 0
    analysis += `| [\`${file.path}\`](${file.path}) | ${status} ${file.score}/100 | ${file.issues?.length || 0} | ${criticalCount} |\n`
  })

  return analysis
}

function generateCategoryDetails(categoryBreakdown) {
  if (
    !categoryBreakdown ||
    typeof categoryBreakdown !== 'object' ||
    Object.keys(categoryBreakdown).length === 0
  ) {
    return 'No category details available.'
  }

  let details = ''

  for (const [category, fileIssues] of Object.entries(categoryBreakdown)) {
    if (Object.keys(fileIssues).length === 0) continue

    details += `### ${category.charAt(0).toUpperCase() + category.slice(1)}\n\n`

    // All Issues Summary Table
    details += '| File | Line:Col | Category | Severity | Issue | Suggestion |\n'
    details += '|------|----------|----------|----------|-------|------------|\n'

    const allIssues = []
    for (const [filePath, issues] of Object.entries(fileIssues)) {
      if (issues && Array.isArray(issues)) {
        issues.forEach(issue => {
          allIssues.push({
            ...issue,
            filePath: filePath.split('/').pop() // Show just filename
          })
        })
      }
    }

    // Sort by severity (error first), then by category, then by line
    allIssues.sort((a, b) => {
      const severityOrder = { error: 0, warning: 1, info: 2 }
      if (severityOrder[a.severity] !== severityOrder[b.severity]) {
        return severityOrder[a.severity] - severityOrder[b.severity]
      }
      if (a.category !== b.category) {
        return a.category.localeCompare(b.category)
      }
      return a.line - b.line
    })

    allIssues.forEach(issue => {
      const severityIcon = getSeverityIcon(issue.severity)
      const location = `${issue.line}:${issue.column}`
      const category = issue.category.charAt(0).toUpperCase() + issue.category.slice(1)
      const severity = issue.severity.charAt(0).toUpperCase() + issue.severity.slice(1)
      const message =
        issue.message.length > 60 ? issue.message.substring(0, 60) + '...' : issue.message
      const suggestion =
        issue.suggestion.length > 60 ? issue.suggestion.substring(0, 60) + '...' : issue.suggestion

      // Make file path clickable
      const clickableFilePath = `[\`${issue.filePath}\`](${issue.filePath})`
      details += `| ${clickableFilePath} | ${location} | ${category} | ${severityIcon} ${severity} | ${message} | ${suggestion} |\n`
    })

    details += '\n---\n\n'

    // Detailed breakdown by file
    for (const [filePath, issues] of Object.entries(fileIssues)) {
      if (!issues || !Array.isArray(issues)) continue

      // Make file path clickable
      const clickableFilePath = `[\`${filePath}\`](${filePath})`
      details += `### 📄 ${clickableFilePath}\n\n`

      // Create table for this file's issues
      details += '| Line:Col | Category | Severity | Issue | Suggestion |\n'
      details += '|----------|----------|----------|-------|------------|\n'

      // Sort issues by line number
      const sortedIssues = issues.sort((a, b) => a.line - b.line)

      sortedIssues.forEach(issue => {
        const severityIcon = getSeverityIcon(issue.severity)
        const location = `${issue.line}:${issue.column}`
        const category = issue.category.charAt(0).toUpperCase() + issue.category.slice(1)
        const severity = issue.severity.charAt(0).toUpperCase() + issue.severity.slice(1)
        const message =
          issue.message.length > 80 ? issue.message.substring(0, 80) + '...' : issue.message
        const suggestion =
          issue.suggestion.length > 80
            ? issue.suggestion.substring(0, 80) + '...'
            : issue.suggestion

        details += `| ${location} | ${category} | ${severityIcon} ${severity} | ${message} | ${suggestion} |\n`
      })

      details += '\n'
    }
  }

  return details
}

function generateAllFilesSummary(files) {
  if (!files || Object.keys(files).length === 0) {
    return 'No files analyzed.'
  }

  let summary = '| File | Score | Issues | Critical |\n'
  summary += '|------|-------|--------|----------|\n'

  Object.values(files).forEach(file => {
    const status = getScoreIcon(file.score)
    const criticalCount =
      file.issues && Array.isArray(file.issues)
        ? file.issues.filter(i => i.severity === 'error').length
        : 0
    summary += `| [\`${file.path}\`](${file.path}) | ${status} ${file.score}/100 | ${file.issues?.length || 0} | ${criticalCount} |\n`
  })

  return summary
}

function generateESLintSection(eslintResults) {
  if (!eslintResults || !eslintResults.files || Object.keys(eslintResults.files).length === 0) {
    return 'No ESLint issues found or ESLint analysis not available.'
  }

  let section = `**Total ESLint Issues:** ${eslintResults.summary?.totalIssues || 0}\n\n`

  // Summary by severity
  if (eslintResults.summary?.issuesBySeverity) {
    section += '**Issues by Severity:**\n'
    Object.entries(eslintResults.summary.issuesBySeverity).forEach(([severity, count]) => {
      if (count > 0) {
        const icon = getSeverityIcon(severity)
        section += `- ${icon} ${severity.charAt(0).toUpperCase() + severity.slice(1)}: ${count}\n`
      }
    })
    section += '\n'
  }

  // Files with ESLint issues
  section += '**Files with ESLint Issues:**\n\n'

  for (const [filePath, fileData] of Object.entries(eslintResults.files)) {
    if (fileData.issues && fileData.issues.length > 0) {
      // Make file path clickable
      const clickableFilePath = `[\`${filePath}\`](${filePath})`
      section += `### 📄 ${clickableFilePath}\n\n`

      // Create table for this file's ESLint issues
      section += '| Line:Col | Rule | Severity | Issue | Suggestion |\n'
      section += '|----------|------|----------|-------|------------|\n'

      // Sort issues by line number
      const sortedIssues = fileData.issues.sort((a, b) => a.line - b.line)

      sortedIssues.forEach(issue => {
        const severityIcon = getSeverityIcon(issue.severity)
        const location = `${issue.line}:${issue.column}`
        const rule = issue.rule.replace('eslint:', '')
        const severity = issue.severity.charAt(0).toUpperCase() + issue.severity.slice(1)
        const message =
          issue.message.length > 80 ? issue.message.substring(0, 80) + '...' : issue.message
        const suggestion =
          issue.suggestion.length > 80
            ? issue.suggestion.substring(0, 80) + '...'
            : issue.suggestion

        section += `| ${location} | ${rule} | ${severityIcon} ${severity} | ${message} | ${suggestion} |\n`
      })

      section += '\n'
    }
  }

  return section
}

function generateDetailedMetrics(results, grades) {
  let metrics = ''

  // File Statistics
  metrics += '#### 📊 File Statistics\n\n'
  metrics += `- **Total Files Scanned:** ${results.summary?.totalFiles || 0}\n`
  metrics += `- **Files with Issues:** ${Object.values(results.files || {}).filter(f => f.issues && f.issues.length > 0).length}\n`
  metrics += `- **Clean Files:** ${Object.values(results.files || {}).filter(f => !f.issues || f.issues.length === 0).length}\n\n`

  // Score Distribution
  metrics += '#### 📈 Score Distribution\n\n'
  const scoreRanges = { '90-100': 0, '80-89': 0, '70-79': 0, '60-69': 0, '0-59': 0 }
  Object.values(results.files || {}).forEach(file => {
    if (file.score >= 90) scoreRanges['90-100']++
    else if (file.score >= 80) scoreRanges['80-89']++
    else if (file.score >= 70) scoreRanges['70-79']++
    else if (file.score >= 60) scoreRanges['60-69']++
    else scoreRanges['0-59']++
  })

  Object.entries(scoreRanges).forEach(([range, count]) => {
    if (count > 0) {
      metrics += `- **${range}:** ${count} files\n`
    }
  })
  metrics += '\n'

  // Issue Severity Distribution
  metrics += '#### 🚨 Issue Severity Distribution\n\n'
  const severityCounts = { error: 0, warning: 0, info: 0 }
  Object.values(results.files || {}).forEach(file => {
    if (file.issues && Array.isArray(file.issues)) {
      file.issues.forEach(issue => {
        severityCounts[issue.severity] = (severityCounts[issue.severity] || 0) + 1
      })
    }
  })

  Object.entries(severityCounts).forEach(([severity, count]) => {
    if (count > 0) {
      const icon = getSeverityIcon(severity)
      metrics += `- **${icon} ${severity.charAt(0).toUpperCase() + severity.slice(1)}:** ${count} issues\n`
    }
  })
  metrics += '\n'

  // Category Impact Analysis
  metrics += '#### 🎯 Category Impact Analysis\n\n'
  const categoryImpact = {}
  Object.values(results.files || {}).forEach(file => {
    if (file.issues && Array.isArray(file.issues)) {
      file.issues.forEach(issue => {
        if (!categoryImpact[issue.category]) {
          categoryImpact[issue.category] = { count: 0, score: 0 }
        }
        categoryImpact[issue.category].count++
        categoryImpact[issue.category].score += file.score
      })
    }
  })

  Object.entries(categoryImpact).forEach(([category, data]) => {
    const avgScore = Math.round(data.score / Object.values(results.files || {}).length)
    metrics += `- **${category.charAt(0).toUpperCase() + category.slice(1)}:** ${data.count} issues, Avg Score: ${avgScore}/100\n`
  })

  return metrics
}

function generatePriorityMatrix(results) {
  let matrix = ''

  // High Priority (Errors)
  const errors = []
  Object.values(results.files || {}).forEach(file => {
    if (file.issues && Array.isArray(file.issues)) {
      file.issues.forEach(issue => {
        if (issue.severity === 'error') {
          errors.push({ ...issue, file: file.path })
        }
      })
    }
  })

  if (errors.length > 0) {
    matrix += '#### 🔴 High Priority (Errors)\n\n'
    matrix += '| File | Line | Issue |\n'
    matrix += '|------|------|-------|\n'
    errors.slice(0, 10).forEach(issue => {
      const clickableFilePath = `[\`${(issue.file || issue.filePath || '').split('/').pop()}\`](${issue.file || issue.filePath || ''})`
      matrix += `| ${clickableFilePath} | ${issue.line}:${issue.column} | ${issue.message.substring(0, 60)}... |\n`
    })
    matrix += '\n'
  }

  // Medium Priority (Warnings)
  const warnings = []
  Object.values(results.files || {}).forEach(file => {
    if (file.issues && Array.isArray(file.issues)) {
      file.issues.forEach(issue => {
        if (issue.severity === 'warning') {
          warnings.push({ ...issue, file: file.path })
        }
      })
    }
  })

  if (warnings.length > 0) {
    matrix += '#### 🟡 Medium Priority (Warnings)\n\n'
    matrix += '| File | Line | Issue |\n'
    matrix += '|------|------|-------|\n'
    warnings.slice(0, 10).forEach(issue => {
      const clickableFilePath = `[\`${(issue.file || issue.filePath || '').split('/').pop()}\`](${issue.file || issue.filePath || ''})`
      matrix += `| ${clickableFilePath} | ${issue.line}:${issue.column} | ${issue.message.substring(0, 60)}... |\n`
    })
    matrix += '\n'
  }

  // Low Priority (Info)
  const info = []
  Object.values(results.files || {}).forEach(file => {
    if (file.issues && Array.isArray(file.issues)) {
      file.issues.forEach(issue => {
        if (issue.severity === 'info') {
          info.push({ ...issue, file: file.path })
        }
      })
    }
  })

  if (info.length > 0) {
    matrix += '#### 🔵 Low Priority (Info)\n\n'
    matrix += '| File | Line | Issue |\n'
    matrix += '|------|------|-------|\n'
    info.slice(0, 10).forEach(issue => {
      const clickableFilePath = `[\`${(issue.file || issue.filePath || '').split('/').pop()}\`](${issue.file || issue.filePath || ''})`
      matrix += `| ${clickableFilePath} | ${issue.line}:${issue.column} | ${issue.message.substring(0, 60)}... |\n`
    })
    matrix += '\n'
  }

  return matrix
}

function generateFixInstructions() {
  return `### 🚨 Critical Issues (Fix First)
- **Errors (🔴):** These must be fixed before production deployment
- **Security Issues:** Address immediately to prevent vulnerabilities
- **PWA Issues:** Required for PWA functionality

### ⚠️ Important Issues (Fix Soon)
- **Warnings (🟡):** These should be addressed in the next development cycle
- **Performance Issues:** Will impact user experience
- **Accessibility Issues:** Required for compliance

### 💡 Enhancement Issues (Fix When Possible)
- **Info (🔵):** These are suggestions for improvement
- **Code Quality:** Will improve maintainability
- **SEO Optimizations:** Will improve search rankings

### 🛠️ General Fix Strategy
1. **Start with Errors** - Fix all critical issues first
2. **Address Warnings** - Fix important issues next
3. **Review Info Items** - Implement improvements when time allows
4. **Re-run Audit** - Verify all issues are resolved
5. **Monitor Regularly** - Run audits during development`
}

function getStatusEmoji(score) {
  if (score >= 90) return '🟢'
  if (score >= 80) return '🟡'
  if (score >= 70) return '🟠'
  if (score >= 60) return '🔴'
  return '⚫'
}

function getSeverityIcon(severity) {
  switch (severity) {
    case 'error':
      return '🔴'
    case 'warning':
      return '🟡'
    case 'info':
      return '🔵'
    default:
      return '⚪'
  }
}

function getScoreIcon(score) {
  if (score >= 90) return '🟢'
  if (score >= 80) return '🟡'
  if (score >= 70) return '🟠'
  if (score >= 60) return '🔴'
  return '⚫'
}

function generatePWASection(pwaResults) {
  if (!pwaResults || Object.keys(pwaResults).length === 0) {
    return 'No PWA analysis results available.'
  }

  let section = `**PWA Score:** ${pwaResults.summary?.pwaScore || 0}/100\n\n`

  if (pwaResults.issues && pwaResults.issues.length > 0) {
    section += '**PWA Issues Found:**\n\n'
    pwaResults.issues.forEach(issue => {
      const severityIcon =
        issue.severity === 'error' ? '🔴' : issue.severity === 'warning' ? '🟡' : '🔵'
      section += `${severityIcon} **${issue.severity.toUpperCase()}:** ${issue.message}\n`
      section += `   - File: ${issue.file}\n`
      section += `   - Suggestion: ${issue.suggestion}\n\n`
    })
  } else {
    section += '✅ No PWA issues found!\n'
  }

  return section
}

async function generateFixReport(fixResults, outputDir) {
  const timestamp = new Date().toISOString()

  const fixReport = `# 🔧 Auto-Fix Report

**Generated:** ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}

**Fixes Applied:** ${fixResults.totalFixes}

**Files Modified:** ${fixResults.fixedFiles}

---

## 📈 Summary

${generateFixSummary(fixResults)}

---

## 📁 Modified Files

${generateModifiedFilesList(fixResults)}

---

## 🔍 Detailed Changes

${generateDetailedChanges(fixResults)}

---

## ⚠️ Important Notes

- **Backup Created:** ${fixResults.backup ? '✅ Yes' : '❌ No'}
- **Dry Run Mode:** ${fixResults.dryRun ? '✅ Yes (no changes made)' : '❌ No (changes applied)'}
- **Manual Review Required:** Some issues may require manual intervention
- **Re-run Audit:** Run the audit again to verify fixes were applied correctly

---

*Generated by Next.js + MUI Audit Toolkit v1.0.0 - Auto-Fix Engine*
`

  const fixReportPath = join(outputDir, 'FIX_REPORT.md')
  writeFileSync(fixReportPath, fixReport)
}

function generateFixSummary(fixResults) {
  let summary = '| Category | Fixes Applied | Files Affected |\n'
  summary += '|----------|---------------|----------------|\n'

  const categories = fixResults.fixesByCategory || {}
  for (const [category, fixes] of Object.entries(categories)) {
    const fixCount = fixes.length
    const fileCount = [...new Set(fixes.map(f => f.file))].length
    summary += `| ${category.charAt(0).toUpperCase() + category.slice(1)} | ${fixCount} | ${fileCount} |\n`
  }

  return summary
}

function generateModifiedFilesList(fixResults) {
  if (!fixResults.modifiedFiles || fixResults.modifiedFiles.length === 0) {
    return 'No files were modified.'
  }

  let list = '| File | Fixes Applied | Status |\n'
  list += '|------|---------------|--------|\n'

  fixResults.modifiedFiles.forEach(file => {
    const status = file.success ? '✅ Success' : '❌ Failed'
    list += `| [${file.path}](${file.path}) | ${file.fixCount} | ${status} |\n`
  })

  return list
}

function generateDetailedChanges(fixResults) {
  if (!fixResults.detailedChanges || fixResults.detailedChanges.length === 0) {
    return 'No detailed changes available.'
  }

  let details = ''

  fixResults.detailedChanges.forEach(change => {
    details += `### 📄 ${change.file}\n\n`
    details += `**Rule:** ${change.rule}\n\n`
    details += `**Description:** ${change.description}\n\n`
    details += `**Location:** Line ${change.line}, Column ${change.column}\n\n`

    if (change.before && change.after) {
      details += '**Before:**\n```javascript\n' + change.before + '\n```\n\n'
      details += '**After:**\n```javascript\n' + change.after + '\n```\n\n'
    }

    details += '---\n\n'
  })

  return details
}
