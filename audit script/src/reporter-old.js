import { writeFileSync, mkdirSync } from 'fs'
import { join } from 'path'
import { getTopIssues, getCategoryBreakdown } from './grader.js'
import chalk from 'chalk'

export async function generateReport(results, grades, outputDir) {
  try {
    // Ensure output directory exists
    mkdirSync(outputDir, { recursive: true })

    // Generate JSON report
    await generateJSONReport(results, grades, outputDir)

    // Generate Markdown report
    await generateMarkdownReport(results, grades, outputDir)

    console.log(chalk.green(`✅ Reports generated in ${outputDir}/`))
  } catch (error) {
    throw new Error(`Failed to generate reports: ${error.message}`)
  }
}

async function generateJSONReport(results, grades, outputDir) {
  const report = {
    metadata: {
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      tool: 'Next.js + MUI Audit Toolkit'
    },
    summary: {
      overallScore: grades.overallScore,
      letterGrade: grades.letterGrade,
      totalFiles: results.summary?.totalFiles || 0,
      totalIssues: grades.totalIssues,
      criticalIssues: grades.criticalIssues,
      categoryScores: grades.categoryScores
    },
    issues: {
      byCategory: getCategoryBreakdown(results),
      bySeverity: results.summary?.issuesBySeverity || {},
      topIssues: getTopIssues(results, 20),
      eslint: results.eslint || {}
    },
    files: results.files,
    manualChecks: {
      responsive: [],
      accessibility: [],
      performance: [],
      notes: []
    }
  }

  const jsonPath = join(outputDir, 'report.json')
  writeFileSync(jsonPath, JSON.stringify(report, null, 2))
}

async function generateMarkdownReport(results, grades, outputDir) {
  const topIssues = getTopIssues(results, 10)
  const categoryBreakdown = getCategoryBreakdown(results)

  const markdown = `# Next.js + MUI Audit Report

## 📊 Executive Summary

**Overall Score:** ${grades.overallScore}/100 (${grades.letterGrade})

**Project Status:** ${getProjectStatus(grades.overallScore)}

**Audit Date:** ${new Date().toLocaleDateString()}

**Total Files Scanned:** ${results.summary?.totalFiles || 0}

**Total Issues Found:** ${grades.totalIssues}

**Critical Issues:** ${grades.criticalIssues}

---

## 🎯 Category Breakdown

${generateCategoryTable(grades.categoryScores)}

---

## 🚨 Top Issues to Fix

${generateTopIssuesTable(topIssues)}

---

## 📁 File-by-File Analysis

${generateFileAnalysis(results.files)}

---

## 🔍 Issue Details by Category

${generateCategoryDetails(categoryBreakdown)}

---

## 📋 ESLint Analysis

${generateESLintSection(results.eslint)}

---

## 📊 Detailed Metrics & Statistics

${generateDetailedMetrics(results.files)}

---

${generateDetailedIssues(results.files)}

---

## ✅ Manual Checks Required

### Responsiveness Testing
Test each major route at various screen sizes (320px to 1440px):

- [ ] Homepage: \`\`\`
- [ ] Dashboard: \`\`\`
- [ ] Forms: \`\`\`

### Accessibility Testing
- [ ] Screen reader compatibility: \`\`\`
- [ ] Keyboard navigation: \`\`\`
- [ ] Color contrast: \`\`\`

### Performance Testing
- [ ] Lighthouse score: \`\`\`
- [ ] Bundle size: \`\`\`
- [ ] Core Web Vitals: \`\`\`

### Notes
\`\`\`

---

## 🛠️ How to Fix Issues

### 🚨 Critical Priority (Fix Immediately)
1. **Fix all error-level issues** - These block deployment and cause failures
2. **Address security vulnerabilities** - XSS, unsafe eval, dangerous HTML
3. **Fix accessibility errors** - Missing alt text, button labels, form labels

### ⚡ High Priority (Fix This Week)
1. **Resolve SEO issues** - Missing meta tags, page titles, Open Graph tags
2. **Fix image optimization** - Convert PNG icons to SVG, add alt attributes
3. **Address responsive design** - Viewport meta tags, fixed dimensions

### 📋 Medium Priority (Fix This Month)
1. **Clean up code quality** - Remove unused imports, console statements
2. **Improve performance** - Optimize expensive operations, reduce client components
3. **Add testing coverage** - Create test files for components

### 🔮 Long-term Improvements (Ongoing)
1. **Enhance accessibility** - Color contrast, keyboard navigation
2. **Optimize bundle size** - Dynamic imports, code splitting
3. **Improve documentation** - README, component docs, API documentation

---

## 📊 Priority Matrix

${generatePriorityMatrix(results.files)}

---

## 📈 Scoring Methodology

- **A (90-100):** Excellent - Follows all best practices
- **B (80-89):** Good - Minor issues to address
- **C (70-79):** Fair - Several issues need attention
- **D (60-69):** Poor - Many issues requiring work
- **F (0-59):** Failing - Critical issues must be resolved

---

*Generated by Next.js + MUI Audit Toolkit v1.0.0 By @dev-mhany*
`

  const mdPath = join(outputDir, 'REPORT.md')
  writeFileSync(mdPath, markdown)
}

function getProjectStatus(score) {
  if (score >= 90) return '🟢 Excellent - Ready for production'
  if (score >= 80) return '🟡 Good - Minor improvements needed'
  if (score >= 70) return '🟠 Fair - Several issues to address'
  if (score >= 60) return '🔴 Poor - Significant work required'
  return '⚫ Critical - Must fix before deployment'
}

function generateCategoryTable(categoryScores) {
  const categories = [
    { name: 'Next.js Architecture', key: 'nextjs', weight: 14 },
    { name: 'MUI Usage', key: 'mui', weight: 14 },
    { name: 'Accessibility', key: 'accessibility', weight: 8 },
    { name: 'Responsive Design', key: 'responsive', weight: 8 },
    { name: 'Performance', key: 'performance', weight: 8 },
    { name: 'Security', key: 'security', weight: 8 },
    { name: 'Code Quality', key: 'quality', weight: 10 },
    { name: 'Testing', key: 'testing', weight: 6 },
    { name: 'SEO', key: 'seo', weight: 8 },
    { name: 'Image Optimization', key: 'image', weight: 6 },
    { name: 'Modern Practices', key: 'modern', weight: 4 },
    { name: 'PWA Essentials', key: 'pwa', weight: 6 }
  ]

  let table = '| Category | Score | Weight | Status |\n'
  table += '|----------|-------|--------|--------|\n'

  for (const category of categories) {
    const score = categoryScores[category.key] || 100
    const status = getStatusEmoji(score)
    table += `| ${category.name} | ${score}/100 | ${category.weight}% | ${status} |\n`
  }

  return table
}

function generateTopIssuesTable(topIssues) {
  if (topIssues.length === 0) {
    return '🎉 No issues found! Your project follows best practices.'
  }

  let table = '| Issue | Count | Category | Severity |\n'
  table += '|-------|-------|----------|----------|\n'

  for (const issue of topIssues) {
    const severityIcon = getSeverityIcon(issue.severity)
    table += `| ${issue.message} | ${issue.count} | ${issue.category} | ${severityIcon} ${issue.severity} |\n`
  }

  return table
}

function generateFileAnalysis(files) {
  if (Object.keys(files).length === 0) {
    return 'No files analyzed.'
  }

  let analysis = '| File | Score | Issues | Critical |\n'
  analysis += '|------|-------|--------|----------|\n'

  // Sort files by score (worst first)
  const sortedFiles = Object.values(files).sort((a, b) => a.score - b.score)

  for (const file of sortedFiles) {
    const criticalCount = file.issues.filter(i => i.severity === 'error').length
    const scoreIcon = getScoreIcon(file.score)

    // Make file path clickable and relative
    const clickablePath = `[\`${file.path}\`](${file.path})`
    analysis += `| ${clickablePath} | ${scoreIcon} ${file.score}/100 | ${file.issues.length} | ${criticalCount} |\n`
  }

  return analysis
}

function generateCategoryDetails(categoryBreakdown) {
  let details = ''

  for (const [category, data] of Object.entries(categoryBreakdown)) {
    if (data.total === 0) continue

    details += `### ${category.charAt(0).toUpperCase() + category.slice(1)}\n`
    details += `**Total Issues:** ${data.total}\n`
    details += `**Files Affected:** ${data.fileCount}\n`
    details += `**By Severity:** ${data.bySeverity.error} errors, ${data.bySeverity.warning} warnings, ${data.bySeverity.info} info\n\n`
  }

  return details
}

function generateDetailedMetrics(files) {
  let metrics = ''

  // File Statistics Table
  metrics += '### 📁 File Statistics\n\n'
  metrics += '| Metric | Value |\n'
  metrics += '|--------|-------|\n'

  const totalFiles = Object.keys(files).length
  const filesWithIssues = Object.values(files).filter(f => f.issues.length > 0).length
  const filesWithErrors = Object.values(files).filter(f =>
    f.issues.some(i => i.severity === 'error')
  ).length
  const filesWithWarnings = Object.values(files).filter(f =>
    f.issues.some(i => i.severity === 'warning')
  ).length

  metrics += `| Total Files | ${totalFiles} |\n`
  metrics += `| Files with Issues | ${filesWithIssues} |\n`
  metrics += `| Files with Errors | ${filesWithErrors} |\n`
  metrics += `| Files with Warnings | ${filesWithWarnings} |\n`
  metrics += `| Clean Files | ${totalFiles - filesWithIssues} |\n`

  // Score Distribution Table
  metrics += '\n### 📈 Score Distribution\n\n'
  metrics += '| Score Range | Count | Percentage |\n'
  metrics += '|-------------|-------|------------|\n'

  const scoreRanges = [
    { range: '90-100', min: 90, max: 100, label: '🟢 Excellent' },
    { range: '80-89', min: 80, max: 89, label: '🟡 Good' },
    { range: '70-79', min: 70, max: 79, label: '🟠 Fair' },
    { range: '60-69', min: 60, max: 69, label: '🔴 Poor' },
    { range: '0-59', min: 0, max: 59, label: '⚫ Critical' }
  ]

  scoreRanges.forEach(range => {
    const count = Object.values(files).filter(
      f => f.score >= range.min && f.score <= range.max
    ).length
    const percentage = totalFiles > 0 ? ((count / totalFiles) * 100).toFixed(1) : 0
    metrics += `| ${range.label} (${range.range}) | ${count} | ${percentage}% |\n`
  })

  // Issue Severity Distribution
  metrics += '\n### 🚨 Issue Severity Distribution\n\n'
  metrics += '| Severity | Count | Percentage |\n'
  metrics += '|----------|-------|------------|\n'

  const allIssues = Object.values(files).flatMap(f => f.issues)
  const errorCount = allIssues.filter(i => i.severity === 'error').length
  const warningCount = allIssues.filter(i => i.severity === 'warning').length
  const infoCount = allIssues.filter(i => i.severity === 'info').length
  const totalIssues = allIssues.length

  if (totalIssues > 0) {
    metrics += `| 🔴 Error | ${errorCount} | ${((errorCount / totalIssues) * 100).toFixed(1)}% |\n`
    metrics += `| 🟡 Warning | ${warningCount} | ${((warningCount / totalIssues) * 100).toFixed(1)}% |\n`
    metrics += `| 🔵 Info | ${infoCount} | ${((infoCount / totalIssues) * 100).toFixed(1)}% |\n`
  }

  // Category Impact Analysis
  metrics += '\n### 🎯 Category Impact Analysis\n\n'
  metrics += '| Category | Issues | Files Affected | Avg Score | Status |\n'
  metrics += '|----------|--------|----------------|-----------|--------|\n'

  const categoryStats = {}
  Object.values(files).forEach(file => {
    file.issues.forEach(issue => {
      if (!categoryStats[issue.category]) {
        categoryStats[issue.category] = { issues: 0, files: new Set(), scores: [] }
      }
      categoryStats[issue.category].issues++
      categoryStats[issue.category].files.add(file.path)
      categoryStats[issue.category].scores.push(file.score)
    })
  })

  Object.entries(categoryStats).forEach(([category, stats]) => {
    const avgScore =
      stats.scores.length > 0
        ? (stats.scores.reduce((a, b) => a + b, 0) / stats.scores.length).toFixed(1)
        : 100
    const status = getStatusEmoji(avgScore)
    const categoryName = category.charAt(0).toUpperCase() + category.slice(1)

    metrics += `| ${categoryName} | ${stats.issues} | ${stats.files.size} | ${avgScore}/100 | ${status} |\n`
  })

  return metrics
}

function generatePriorityMatrix(files) {
  let matrix = ''

  // Priority Matrix Table
  matrix += '| Priority | Issues | Impact | Effort | Recommendation |\n'
  matrix += '|----------|--------|--------|--------|----------------|\n'

  const allIssues = Object.values(files).flatMap(f => f.issues)
  const errorIssues = allIssues.filter(i => i.severity === 'error')
  const warningIssues = allIssues.filter(i => i.severity === 'warning')
  const infoIssues = allIssues.filter(i => i.severity === 'info')

  // Critical Priority
  if (errorIssues.length > 0) {
    matrix += `| 🔴 Critical | ${errorIssues.length} | High | Low | Fix immediately - blocks deployment |\n`
  }

  // High Priority
  if (warningIssues.length > 0) {
    const highPriorityIssues = warningIssues.filter(i =>
      ['seo', 'image', 'responsive', 'accessibility'].includes(i.category)
    )
    if (highPriorityIssues.length > 0) {
      matrix += `| 🟡 High | ${highPriorityIssues.length} | High | Medium | Fix this week - affects user experience |\n`
    }
  }

  // Medium Priority
  if (warningIssues.length > 0) {
    const mediumPriorityIssues = warningIssues.filter(i =>
      ['quality', 'performance', 'testing'].includes(i.category)
    )
    if (mediumPriorityIssues.length > 0) {
      matrix += `| 🟠 Medium | ${mediumPriorityIssues.length} | Medium | Medium | Fix this month - improves code quality |\n`
    }
  }

  // Low Priority
  if (infoIssues.length > 0) {
    matrix += `| 🔵 Low | ${infoIssues.length} | Low | Low | Fix when convenient - nice to have |\n`
  }

  matrix += '\n'

  // Issue Count by Priority
  matrix += '### 📈 Issue Count by Priority\n\n'
  matrix += '| Priority | Count | Percentage |\n'
  matrix += '|----------|-------|------------|\n'

  const totalIssues = allIssues.length
  if (totalIssues > 0) {
    matrix += `| 🔴 Critical | ${errorIssues.length} | ${((errorIssues.length / totalIssues) * 100).toFixed(1)}% |\n`
    matrix += `| 🟡 High | ${warningIssues.length} | ${((warningIssues.length / totalIssues) * 100).toFixed(1)}% |\n`
    matrix += `| 🔵 Low | ${infoIssues.length} | ${((infoIssues.length / totalIssues) * 100).toFixed(1)}% |\n`
  }

  return matrix
}

function generateDetailedIssues(files) {
  let details = '\n## 📍 Detailed Issue Locations\n\n'

  // Group issues by file
  const fileIssues = {}
  for (const [filePath, fileData] of Object.entries(files)) {
    if (fileData.issues.length > 0) {
      fileIssues[filePath] = fileData.issues
    }
  }

  if (Object.keys(fileIssues).length === 0) {
    return details + '🎉 No issues found!'
  }

  // Create a comprehensive table for all issues
  details += '### 📊 All Issues Summary Table\n\n'
  details += '| File | Line:Col | Category | Severity | Issue | Suggestion |\n'
  details += '|------|----------|----------|----------|-------|------------|\n'

  const allIssues = []
  for (const [filePath, issues] of Object.entries(fileIssues)) {
    issues.forEach(issue => {
      allIssues.push({
        ...issue,
        filePath: filePath.split('/').pop() // Show just filename
      })
    })
  }

  // Sort by severity (error first), then by category, then by line
  allIssues.sort((a, b) => {
    const severityOrder = { error: 0, warning: 1, info: 2 }
    if (severityOrder[a.severity] !== severityOrder[b.severity]) {
      return severityOrder[a.severity] - severityOrder[b.severity]
    }
    if (a.category !== b.category) {
      return a.category.localeCompare(b.category)
    }
    return a.line - b.line
  })

  allIssues.forEach(issue => {
    const severityIcon = getSeverityIcon(issue.severity)
    const location = `${issue.line}:${issue.column}`
    const category = issue.category.charAt(0).toUpperCase() + issue.category.slice(1)
    const severity = issue.severity.charAt(0).toUpperCase() + issue.severity.slice(1)
    const message =
      issue.message.length > 60 ? issue.message.substring(0, 60) + '...' : issue.message
    const suggestion =
      issue.suggestion.length > 60 ? issue.suggestion.substring(0, 60) + '...' : issue.suggestion

    // Make file path clickable
    const clickableFilePath = `[\`${issue.filePath}\`](${issue.filePath})`
    details += `| ${clickableFilePath} | ${location} | ${category} | ${severityIcon} ${severity} | ${message} | ${suggestion} |\n`
  })

  details += '\n---\n\n'

  // Detailed breakdown by file
  for (const [filePath, issues] of Object.entries(fileIssues)) {
    // Make file path clickable
    const clickableFilePath = `[\`${filePath}\`](${filePath})`
    details += `### 📄 ${clickableFilePath}\n\n`

    // Create table for this file's issues
    details += '| Line:Col | Category | Severity | Issue | Suggestion |\n'
    details += '|----------|----------|----------|-------|------------|\n'

    // Sort issues by line number
    const sortedIssues = issues.sort((a, b) => a.line - b.line)

    sortedIssues.forEach(issue => {
      const severityIcon = getSeverityIcon(issue.severity)
      const location = `${issue.line}:${issue.column}`
      const category = issue.category.charAt(0).toUpperCase() + issue.category.slice(1)
      const severity = issue.severity.charAt(0).toUpperCase() + issue.severity.slice(1)
      const message =
        issue.message.length > 80 ? issue.message.substring(0, 80) + '...' : issue.message
      const suggestion =
        issue.suggestion.length > 80 ? issue.suggestion.substring(0, 80) + '...' : issue.suggestion

      details += `| ${location} | ${category} | ${severityIcon} ${severity} | ${message} | ${suggestion} |\n`
    })

    details += '\n'
  }

  return details
}

function getStatusEmoji(score) {
  if (score >= 90) return '🟢'
  if (score >= 80) return '🟡'
  if (score >= 70) return '🟠'
  if (score >= 60) return '🔴'
  return '⚫'
}

function getSeverityIcon(severity) {
  switch (severity) {
    case 'error':
      return '🔴'
    case 'warning':
      return '🟡'
    case 'info':
      return '🔵'
    default:
      return '⚪'
  }
}

function getScoreIcon(score) {
  if (score >= 90) return '🟢'
  if (score >= 80) return '🟡'
  if (score >= 70) return '🟠'
  if (score >= 60) return '��'
  return '⚫'
}
