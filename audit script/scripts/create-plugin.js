#!/usr/bin/env node

/**
 * Plugin Template Generator
 *
 * Generates plugin templates for the Next.js + MUI Audit Toolkit
 */

import { writeFile, mkdir } from 'fs/promises'
import { join } from 'path'
import { existsSync } from 'fs'

const templates = {
  basic: {
    name: 'Basic Plugin Template',
    description: 'Simple plugin with basic rule structure',
    template: (pluginName, options) => `/**
 * ${pluginName} Plugin
 * 
 * Generated by Plugin Template Generator
 */

export default {
  name: '${pluginName}',
  version: '1.0.0',
  description: '${options.description || 'Custom audit plugin'}',
  author: '${options.author || 'Your Name'}',
  
  rules: [
    {
      id: '${pluginName}/example-rule',
      category: '${options.category || 'custom'}',
      severity: 'warning',
      message: 'Example rule violation',
      suggestion: 'Fix the example issue',
      pattern: /example-pattern/g,
      shouldCheck: (relativePath) => {
        return /\\.(jsx?|tsx?)$/.test(relativePath);
      }
    }
  ],
  
  hooks: {
    afterScan: async (results) => {
      console.log('${pluginName} plugin: Scan completed');
    }
  },
  
  configSchema: {
    ${pluginName.replace(/-/g, '')}: {
      enabled: true
    }
  }
};`
  },

  advanced: {
    name: 'Advanced Plugin Template',
    description: 'Comprehensive plugin with hooks, processors, and custom logic',
    template: (pluginName, options) => `/**
 * ${pluginName} Plugin
 * 
 * Generated by Plugin Template Generator
 */

export default {
  name: '${pluginName}',
  version: '1.0.0',
  description: '${options.description || 'Advanced custom audit plugin'}',
  author: '${options.author || 'Your Name'}',
  
  rules: [
    {
      id: '${pluginName}/custom-check',
      category: '${options.category || 'custom'}',
      severity: '${options.severity || 'warning'}',
      message: 'Custom check failed',
      suggestion: 'Follow the recommended pattern',
      shouldCheck: (relativePath) => {
        return /\\.(jsx?|tsx?)$/.test(relativePath) && 
               !relativePath.includes('test') &&
               !relativePath.includes('spec');
      },
      checkFunction: (content, lines, filePath) => {
        const issues = [];
        
        // Add your custom logic here
        // Example: Check for specific patterns
        const pattern = /your-pattern-here/g;
        let match;
        
        while ((match = pattern.exec(content)) !== null) {
          const location = this.getLocation(content, match.index);
          issues.push({
            rule: '${pluginName}/custom-check',
            category: '${options.category || 'custom'}',
            severity: '${options.severity || 'warning'}',
            message: 'Custom pattern detected',
            line: location.line,
            column: location.column,
            excerpt: lines[location.line - 1]?.trim() || '',
            suggestion: 'Replace with recommended pattern',
            file: filePath,
            exactLocation: \`\${filePath}:\${location.line}:\${location.column}\`
          });
        }
        
        return issues;
      }
    }
  ],
  
  processors: {
    '.json': (content, filePath) => {
      // Process JSON files if needed
      return content;
    }
  },
  
  hooks: {
    beforeScan: async (context) => {
      console.log('${pluginName}: Starting scan');
    },
    
    afterScan: async (results) => {
      const customIssues = Object.values(results.files || {})
        .flat()
        .filter(issue => issue.rule.startsWith('${pluginName}/'));
      
      console.log(\`${pluginName}: Found \${customIssues.length} custom issues\`);
    },
    
    beforeGrading: async (results) => {
      // Modify results before grading if needed
    },
    
    afterGrading: async (grades) => {
      // Provide custom feedback based on grades
    }
  },
  
  configSchema: {
    ${pluginName.replace(/-/g, '')}: {
      enabled: true,
      strictMode: false,
      customOption: 'default-value'
    }
  },
  
  initialize: async function() {
    console.log('${pluginName} plugin initialized');
  },
  
  // Helper methods
  getLocation: function(content, index) {
    const lines = content.substring(0, index).split('\\\\n');
    return {
      line: lines.length,
      column: lines[lines.length - 1].length + 1
    };
  }
};`
  },

  accessibility: {
    name: 'Accessibility Plugin Template',
    description: 'Template for accessibility-focused plugins',
    template: (pluginName, options) => `/**
 * ${pluginName} Accessibility Plugin
 * 
 * Generated by Plugin Template Generator
 */

export default {
  name: '${pluginName}',
  version: '1.0.0',
  description: '${options.description || 'Accessibility audit plugin'}',
  author: '${options.author || 'Your Name'}',
  
  rules: [
    {
      id: '${pluginName}/missing-aria-label',
      category: 'accessibility',
      severity: 'warning',
      message: 'Interactive element missing accessible label',
      suggestion: 'Add aria-label or aria-labelledby attribute',
      shouldCheck: (relativePath) => /\\.(jsx?|tsx?)$/.test(relativePath),
      checkFunction: (content, lines, filePath) => {
        const issues = [];
        
        // Check for buttons without accessible labels
        const buttonPattern = /<button[^>]*>/g;
        let match;
        
        while ((match = buttonPattern.exec(content)) !== null) {
          const button = match[0];
          const hasAriaLabel = button.includes('aria-label');
          const hasAriaLabelledby = button.includes('aria-labelledby');
          const hasTextContent = !button.includes('/>'); // Not self-closing
          
          if (!hasAriaLabel && !hasAriaLabelledby && !hasTextContent) {
            const location = this.getLocation(content, match.index);
            issues.push({
              rule: '${pluginName}/missing-aria-label',
              category: 'accessibility',
              severity: 'warning',
              message: 'Button element needs accessible label',
              line: location.line,
              column: location.column,
              excerpt: lines[location.line - 1]?.trim() || '',
              suggestion: 'Add aria-label attribute or visible text content',
              file: filePath,
              exactLocation: \`\${filePath}:\${location.line}:\${location.column}\`
            });
          }
        }
        
        return issues;
      }
    }
  ],
  
  hooks: {
    afterGrading: async (grades) => {
      const a11yScore = grades.categoryScores?.accessibility || 0;
      
      if (a11yScore < 90) {
        console.log('♿ ${pluginName}: Consider accessibility testing with:');
        console.log('   • Screen readers (NVDA, JAWS, VoiceOver)');
        console.log('   • Keyboard navigation testing');
        console.log('   • Color contrast analyzers');
      }
    }
  },
  
  configSchema: {
    ${pluginName.replace(/-/g, '')}: {
      enabled: true,
      wcagLevel: 'AA',
      strictMode: false
    }
  },
  
  getLocation: function(content, index) {
    const lines = content.substring(0, index).split('\\\\n');
    return {
      line: lines.length,
      column: lines[lines.length - 1].length + 1
    };
  }
};`
  },

  performance: {
    name: 'Performance Plugin Template',
    description: 'Template for performance-focused plugins',
    template: (pluginName, options) => `/**
 * ${pluginName} Performance Plugin
 * 
 * Generated by Plugin Template Generator
 */

export default {
  name: '${pluginName}',
  version: '1.0.0',
  description: '${options.description || 'Performance optimization plugin'}',
  author: '${options.author || 'Your Name'}',
  
  rules: [
    {
      id: '${pluginName}/large-bundle-import',
      category: 'performance',
      severity: 'warning',
      message: 'Large library import detected',
      suggestion: 'Use specific imports to reduce bundle size',
      pattern: /import\\s+.*\\s+from\\s+['"]${options.libraryPattern || 'large-library'}['"]/g,
      checkFunction: (content, lines, filePath) => {
        const issues = [];
        
        // Custom performance checks
        const largeImports = [
          { pattern: /import\\s+.*\\s+from\\s+['"]moment['"]/, library: 'moment', alternative: 'date-fns' },
          { pattern: /import\\s+.*\\s+from\\s+['"]lodash['"]/, library: 'lodash', alternative: 'lodash/function' }
        ];
        
        largeImports.forEach(({ pattern, library, alternative }) => {
          let match;
          while ((match = pattern.exec(content)) !== null) {
            const location = this.getLocation(content, match.index);
            issues.push({
              rule: '${pluginName}/large-bundle-import',
              category: 'performance',
              severity: 'warning',
              message: \`Importing entire \${library} library may increase bundle size\`,
              line: location.line,
              column: location.column,
              excerpt: lines[location.line - 1]?.trim() || '',
              suggestion: \`Consider using \${alternative} for smaller bundle size\`,
              file: filePath,
              exactLocation: \`\${filePath}:\${location.line}:\${location.column}\`
            });
          }
        });
        
        return issues;
      }
    }
  ],
  
  hooks: {
    afterGrading: async (grades) => {
      const perfScore = grades.categoryScores?.performance || 0;
      
      if (perfScore < 80) {
        console.log('⚡ ${pluginName}: Performance optimizations needed:');
        console.log('   • Analyze bundle size with webpack-bundle-analyzer');
        console.log('   • Consider code splitting and lazy loading');
        console.log('   • Optimize images and assets');
      }
    }
  },
  
  configSchema: {
    ${pluginName.replace(/-/g, '')}: {
      enabled: true,
      bundleSizeLimit: '200kb',
      trackLargeImports: true
    }
  },
  
  getLocation: function(content, index) {
    const lines = content.substring(0, index).split('\\\\n');
    return {
      line: lines.length,
      column: lines[lines.length - 1].length + 1
    };
  }
};`
  }
}

async function generatePlugin(templateType, pluginName, options = {}) {
  if (!templates[templateType]) {
    throw new Error(
      `Template type "${templateType}" not found. Available: ${Object.keys(templates).join(', ')}`
    )
  }

  const template = templates[templateType]
  const pluginContent = template.template(pluginName, options)

  // Create plugins directory if it doesn't exist
  const pluginsDir = join(process.cwd(), 'plugins')
  if (!existsSync(pluginsDir)) {
    await mkdir(pluginsDir, { recursive: true })
  }

  const fileName = `${pluginName}.js`
  const filePath = join(pluginsDir, fileName)

  if (existsSync(filePath) && !options.overwrite) {
    throw new Error(`Plugin file "${fileName}" already exists. Use --overwrite to replace it.`)
  }

  await writeFile(filePath, pluginContent)

  return {
    templateType,
    pluginName,
    fileName,
    filePath,
    template: template.name
  }
}

// CLI interface
async function main() {
  const args = process.argv.slice(2)

  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    console.log(`\n🔌 Plugin Template Generator

Usage: node create-plugin.js <template-type> <plugin-name> [options]

Templates:
  basic         - Simple plugin with basic rules
  advanced      - Comprehensive plugin with all features
  accessibility - Accessibility-focused plugin
  performance   - Performance optimization plugin

Options:
  --description "Plugin description"
  --author "Your Name"
  --category "custom"
  --severity "warning"
  --overwrite    Overwrite existing plugin file

Examples:
  node create-plugin.js basic my-custom-plugin
  node create-plugin.js accessibility a11y-checker --author "Team"
  node create-plugin.js performance bundle-optimizer --description "Bundle size optimizer"
`)
    return
  }

  const templateType = args[0]
  const pluginName = args[1]

  if (!pluginName) {
    console.error('❌ Plugin name is required')
    process.exit(1)
  }

  // Parse options
  const options = {}
  for (let i = 2; i < args.length; i++) {
    if (args[i] === '--description' && args[i + 1]) {
      options.description = args[++i]
    } else if (args[i] === '--author' && args[i + 1]) {
      options.author = args[++i]
    } else if (args[i] === '--category' && args[i + 1]) {
      options.category = args[++i]
    } else if (args[i] === '--severity' && args[i + 1]) {
      options.severity = args[++i]
    } else if (args[i] === '--overwrite') {
      options.overwrite = true
    }
  }

  try {
    const result = await generatePlugin(templateType, pluginName, options)

    console.log('✅ Plugin generated successfully!')
    console.log(`📁 File: ${result.filePath}`)
    console.log(`🔧 Template: ${result.template}`)
    console.log(`📦 Plugin Name: ${result.pluginName}`)
    console.log('')
    console.log('Next steps:')
    console.log('1. Edit the generated plugin file to add your custom logic')
    console.log(
      '2. Test your plugin: npx nextjs-mui-audit plugin --load ./plugins/' + result.fileName
    )
    console.log('3. Add your plugin to audit.config.js to use it in audits')
  } catch (error) {
    console.error('❌ Failed to generate plugin:', error.message)
    process.exit(1)
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(console.error)
}

export { generatePlugin, templates }
