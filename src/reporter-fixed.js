import { writeFileSync, mkdirSync } from 'fs'
import { join } from 'path'
import { getTopIssues, getCategoryBreakdown } from './grader.js'
import chalk from 'chalk'

export async function generateReport(results, grades, outputDir) {
  try {
    // Ensure output directory exists
    mkdirSync(outputDir, { recursive: true })

    // Generate JSON report
    await generateJSONReport(results, grades, outputDir)

    // Generate Markdown report
    await generateMarkdownReport(results, grades, outputDir)

    console.log(chalk.green(`âœ… Reports generated in ${outputDir}/`))
  } catch (error) {
    throw new Error(`Failed to generate reports: ${error.message}`)
  }
}

async function generateJSONReport(results, grades, outputDir) {
  const report = {
    metadata: {
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      tool: 'Next.js + MUI Audit Toolkit'
    },
    summary: {
      overallScore: grades.overallScore,
      letterGrade: grades.letterGrade,
      totalFiles: results.summary?.totalFiles || 0,
      totalIssues: grades.totalIssues,
      criticalIssues: grades.criticalIssues,
      categoryScores: grades.categoryScores
    },
    issues: {
      byCategory: getCategoryBreakdown(results),
      bySeverity: results.summary?.issuesBySeverity || {},
      topIssues: getTopIssues(results, 20),
      eslint: results.eslint || {}
    },
    files: results.files,
    manualChecks: {
      responsive: [],
      accessibility: [],
      performance: [],
      notes: []
    }
  }

  const jsonPath = join(outputDir, 'report.json')
  writeFileSync(jsonPath, JSON.stringify(report, null, 2))
}

async function generateMarkdownReport(results, grades, outputDir) {
  const topIssues = getTopIssues(results, 10)
  const categoryBreakdown = getCategoryBreakdown(results)

  const markdown = `# Next.js + MUI Audit Report

## ğŸ“Š Executive Summary

**Overall Score:** ${grades.overallScore}/100 (${grades.letterGrade})

**Project Status:** ${getProjectStatus(grades.overallScore)}

**Audit Date:** ${new Date().toLocaleDateString()}

**Total Files Scanned:** ${results.summary?.totalFiles || 0}

**Total Issues Found:** ${grades.totalIssues}

**Critical Issues:** ${grades.criticalIssues}

---

## ğŸ¯ Category Breakdown

${generateCategoryTable(grades.categoryScores)}

---

## ğŸš¨ Top Issues to Fix

${generateTopIssuesTable(topIssues)}

---

## ğŸ“ File-by-File Analysis

${generateFileAnalysis(results.files)}

---

## ğŸ” Issue Details by Category

${generateCategoryDetails(categoryBreakdown)}

---

## ğŸ“‹ ESLint Analysis

${generateESLintSection(results.eslint)}

---

## ğŸ“ˆ Detailed Metrics & Statistics

${generateDetailedMetrics(results, grades)}

---

## ğŸ¯ Priority Matrix

${generatePriorityMatrix(results)}

---

## ğŸ› ï¸ How to Fix Issues

${generateFixInstructions()}

---

*Generated by Next.js + MUI Audit Toolkit v1.0.0 By @dev-mhany*
`

  const markdownPath = join(outputDir, 'REPORT.md')
  writeFileSync(markdownPath, markdown)
}

function getProjectStatus(score) {
  if (score >= 90) return 'ğŸŸ¢ Excellent - Production Ready'
  if (score >= 80) return 'ğŸŸ¡ Good - Minor Issues to Fix'
  if (score >= 70) return 'ğŸŸ  Fair - Several Issues to Address'
  if (score >= 60) return 'ğŸ”´ Poor - Major Issues to Fix'
  return 'âš« Critical - Immediate Action Required'
}

function generateCategoryTable(categoryScores) {
  const categories = [
    { name: 'Next.js Architecture', key: 'nextjs', weight: 14 },
    { name: 'MUI Usage', key: 'mui', weight: 14 },
    { name: 'Accessibility', key: 'accessibility', weight: 8 },
    { name: 'Responsive Design', key: 'responsive', weight: 8 },
    { name: 'Performance', key: 'performance', weight: 8 },
    { name: 'Security', key: 'security', weight: 8 },
    { name: 'Code Quality', key: 'quality', weight: 10 },
    { name: 'Testing', key: 'testing', weight: 6 },
    { name: 'SEO', key: 'seo', weight: 8 },
    { name: 'Image Optimization', key: 'image', weight: 6 },
    { name: 'Modern Practices', key: 'modern', weight: 4 },
    { name: 'PWA Essentials', key: 'pwa', weight: 6 }
  ]

  let table = '| Category | Score | Weight | Status |\n'
  table += '|----------|-------|--------|--------|\n'

  categories.forEach(category => {
    const score = categoryScores[category.key] || 0
    const status = getStatusEmoji(score)
    table += `| ${category.name} | ${score}/100 | ${category.weight} | ${status} |\n`
  })

  return table
}

function generateTopIssuesTable(topIssues) {
  if (topIssues.length === 0) {
    return 'âœ… No critical issues found!'
  }

  let table = '| File | Line:Col | Category | Severity | Issue |\n'
  table += '|------|----------|----------|----------|-------|\n'

  topIssues.forEach(issue => {
    const severityIcon = getSeverityIcon(issue.severity)
    const location = `${issue.line}:${issue.column}`
    const category = issue.category.charAt(0).toUpperCase() + issue.category.slice(1)
    const severity = issue.severity.charAt(0).toUpperCase() + issue.severity.slice(1)
    const message =
      issue.message.length > 60 ? issue.message.substring(0, 60) + '...' : issue.message

    // Make file path clickable
    const clickableFilePath = `[\`${issue.file.split('/').pop()}\`](${issue.file})`
    table += `| ${clickableFilePath} | ${location} | ${category} | ${severityIcon} ${severity} | ${message} |\n`
  })

  return table
}

function generateFileAnalysis(files) {
  if (!files || Object.keys(files).length === 0) {
    return 'No files analyzed.'
  }

  let analysis = '| File | Score | Issues | Critical |\n'
  analysis += '|------|-------|--------|----------|\n'

  Object.values(files).forEach(file => {
    const status = getScoreIcon(file.score)
    const criticalCount = file.issues?.filter(i => i.severity === 'error').length || 0
    analysis += `| [\`${file.path}\`](${file.path}) | ${status} ${file.score}/100 | ${file.issues?.length || 0} | ${criticalCount} |\n`
  })

  return analysis
}

function generateCategoryDetails(categoryBreakdown) {
  if (!categoryBreakdown || Object.keys(categoryBreakdown).length === 0) {
    return 'No category details available.'
  }

  let details = ''

  for (const [category, fileIssues] of Object.entries(categoryBreakdown)) {
    if (Object.keys(fileIssues).length === 0) continue

    details += `### ${category.charAt(0).toUpperCase() + category.slice(1)}\n\n`

    // All Issues Summary Table
    details += '| File | Line:Col | Category | Severity | Issue | Suggestion |\n'
    details += '|------|----------|----------|----------|-------|------------|\n'

    const allIssues = []
    for (const [filePath, issues] of Object.entries(fileIssues)) {
      issues.forEach(issue => {
        allIssues.push({
          ...issue,
          filePath: filePath.split('/').pop() // Show just filename
        })
      })
    }

    // Sort by severity (error first), then by category, then by line
    allIssues.sort((a, b) => {
      const severityOrder = { error: 0, warning: 1, info: 2 }
      if (severityOrder[a.severity] !== severityOrder[b.severity]) {
        return severityOrder[a.severity] - severityOrder[b.severity]
      }
      if (a.category !== b.category) {
        return a.category.localeCompare(b.category)
      }
      return a.line - b.line
    })

    allIssues.forEach(issue => {
      const severityIcon = getSeverityIcon(issue.severity)
      const location = `${issue.line}:${issue.column}`
      const category = issue.category.charAt(0).toUpperCase() + issue.category.slice(1)
      const severity = issue.severity.charAt(0).toUpperCase() + issue.severity.slice(1)
      const message =
        issue.message.length > 60 ? issue.message.substring(0, 60) + '...' : issue.message
      const suggestion =
        issue.suggestion.length > 60 ? issue.suggestion.substring(0, 60) + '...' : issue.suggestion

      // Make file path clickable
      const clickableFilePath = `[\`${issue.filePath}\`](${issue.filePath})`
      details += `| ${clickableFilePath} | ${location} | ${category} | ${severityIcon} ${severity} | ${message} | ${suggestion} |\n`
    })

    details += '\n---\n\n'

    // Detailed breakdown by file
    for (const [filePath, issues] of Object.entries(fileIssues)) {
      // Make file path clickable
      const clickableFilePath = `[\`${filePath}\`](${filePath})`
      details += `### ğŸ“„ ${clickableFilePath}\n\n`

      // Create table for this file's issues
      details += '| Line:Col | Category | Severity | Issue | Suggestion |\n'
      details += '|----------|----------|----------|-------|------------|\n'

      // Sort issues by line number
      const sortedIssues = issues.sort((a, b) => a.line - b.line)

      sortedIssues.forEach(issue => {
        const severityIcon = getSeverityIcon(issue.severity)
        const location = `${issue.line}:${issue.column}`
        const category = issue.category.charAt(0).toUpperCase() + issue.category.slice(1)
        const severity = issue.severity.charAt(0).toUpperCase() + issue.severity.slice(1)
        const message =
          issue.message.length > 80 ? issue.message.substring(0, 80) + '...' : issue.message
        const suggestion =
          issue.suggestion.length > 80
            ? issue.suggestion.substring(0, 80) + '...'
            : issue.suggestion

        details += `| ${location} | ${category} | ${severityIcon} ${severity} | ${message} | ${suggestion} |\n`
      })

      details += '\n'
    }
  }

  return details
}

function generateESLintSection(eslintResults) {
  if (!eslintResults || !eslintResults.files || Object.keys(eslintResults.files).length === 0) {
    return 'No ESLint issues found or ESLint analysis not available.'
  }

  let section = `**Total ESLint Issues:** ${eslintResults.summary?.totalIssues || 0}\n\n`

  // Summary by severity
  if (eslintResults.summary?.issuesBySeverity) {
    section += '**Issues by Severity:**\n'
    Object.entries(eslintResults.summary.issuesBySeverity).forEach(([severity, count]) => {
      if (count > 0) {
        const icon = getSeverityIcon(severity)
        section += `- ${icon} ${severity.charAt(0).toUpperCase() + severity.slice(1)}: ${count}\n`
      }
    })
    section += '\n'
  }

  // Files with ESLint issues
  section += '**Files with ESLint Issues:**\n\n'

  for (const [filePath, fileData] of Object.entries(eslintResults.files)) {
    if (fileData.issues && fileData.issues.length > 0) {
      // Make file path clickable
      const clickableFilePath = `[\`${filePath}\`](${filePath})`
      section += `### ğŸ“„ ${clickableFilePath}\n\n`

      // Create table for this file's ESLint issues
      section += '| Line:Col | Rule | Severity | Issue | Suggestion |\n'
      section += '|----------|------|----------|-------|------------|\n'

      // Sort issues by line number
      const sortedIssues = fileData.issues.sort((a, b) => a.line - b.line)

      sortedIssues.forEach(issue => {
        const severityIcon = getSeverityIcon(issue.severity)
        const location = `${issue.line}:${issue.column}`
        const rule = issue.rule.replace('eslint:', '')
        const severity = issue.severity.charAt(0).toUpperCase() + issue.severity.slice(1)
        const message =
          issue.message.length > 80 ? issue.message.substring(0, 80) + '...' : issue.message
        const suggestion =
          issue.suggestion.length > 80
            ? issue.suggestion.substring(0, 80) + '...'
            : issue.suggestion

        section += `| ${location} | ${rule} | ${severityIcon} ${severity} | ${message} | ${suggestion} |\n`
      })

      section += '\n'
    }
  }

  return section
}

function generateDetailedMetrics(results, grades) {
  let metrics = ''

  // File Statistics
  metrics += '#### ğŸ“Š File Statistics\n\n'
  metrics += `- **Total Files Scanned:** ${results.summary?.totalFiles || 0}\n`
  metrics += `- **Files with Issues:** ${Object.values(results.files || {}).filter(f => f.issues && f.issues.length > 0).length}\n`
  metrics += `- **Clean Files:** ${Object.values(results.files || {}).filter(f => !f.issues || f.issues.length === 0).length}\n\n`

  // Score Distribution
  metrics += '#### ğŸ“ˆ Score Distribution\n\n'
  const scoreRanges = { '90-100': 0, '80-89': 0, '70-79': 0, '60-69': 0, '0-59': 0 }
  Object.values(results.files || {}).forEach(file => {
    if (file.score >= 90) scoreRanges['90-100']++
    else if (file.score >= 80) scoreRanges['80-89']++
    else if (file.score >= 70) scoreRanges['70-79']++
    else if (file.score >= 60) scoreRanges['60-69']++
    else scoreRanges['0-59']++
  })

  Object.entries(scoreRanges).forEach(([range, count]) => {
    if (count > 0) {
      metrics += `- **${range}:** ${count} files\n`
    }
  })
  metrics += '\n'

  // Issue Severity Distribution
  metrics += '#### ğŸš¨ Issue Severity Distribution\n\n'
  const severityCounts = { error: 0, warning: 0, info: 0 }
  Object.values(results.files || {}).forEach(file => {
    file.issues?.forEach(issue => {
      severityCounts[issue.severity] = (severityCounts[issue.severity] || 0) + 1
    })
  })

  Object.entries(severityCounts).forEach(([severity, count]) => {
    if (count > 0) {
      const icon = getSeverityIcon(severity)
      metrics += `- **${icon} ${severity.charAt(0).toUpperCase() + severity.slice(1)}:** ${count} issues\n`
    }
  })
  metrics += '\n'

  // Category Impact Analysis
  metrics += '#### ğŸ¯ Category Impact Analysis\n\n'
  const categoryImpact = {}
  Object.values(results.files || {}).forEach(file => {
    file.issues?.forEach(issue => {
      if (!categoryImpact[issue.category]) {
        categoryImpact[issue.category] = { count: 0, score: 0 }
      }
      categoryImpact[issue.category].count++
      categoryImpact[issue.category].score += file.score
    })
  })

  Object.entries(categoryImpact).forEach(([category, data]) => {
    const avgScore = Math.round(data.score / Object.values(results.files || {}).length)
    metrics += `- **${category.charAt(0).toUpperCase() + category.slice(1)}:** ${data.count} issues, Avg Score: ${avgScore}/100\n`
  })

  return metrics
}

function generatePriorityMatrix(results) {
  let matrix = ''

  // High Priority (Errors)
  const errors = []
  Object.values(results.files || {}).forEach(file => {
    file.issues?.forEach(issue => {
      if (issue.severity === 'error') {
        errors.push({ ...issue, file: file.path })
      }
    })
  })

  if (errors.length > 0) {
    matrix += '#### ğŸ”´ High Priority (Errors)\n\n'
    matrix += '| File | Line | Issue |\n'
    matrix += '|------|------|-------|\n'
    errors.slice(0, 10).forEach(issue => {
      const clickableFilePath = `[\`${issue.file.split('/').pop()}\`](${issue.file})`
      matrix += `| ${clickableFilePath} | ${issue.line}:${issue.column} | ${issue.message.substring(0, 60)}... |\n`
    })
    matrix += '\n'
  }

  // Medium Priority (Warnings)
  const warnings = []
  Object.values(results.files || {}).forEach(file => {
    file.issues?.forEach(issue => {
      if (issue.severity === 'warning') {
        warnings.push({ ...issue, file: file.path })
      }
    })
  })

  if (warnings.length > 0) {
    matrix += '#### ğŸŸ¡ Medium Priority (Warnings)\n\n'
    matrix += '| File | Line | Issue |\n'
    matrix += '|------|------|-------|\n'
    warnings.slice(0, 10).forEach(issue => {
      const clickableFilePath = `[\`${issue.file.split('/').pop()}\`](${issue.file})`
      matrix += `| ${clickableFilePath} | ${issue.line}:${issue.column} | ${issue.message.substring(0, 60)}... |\n`
    })
    matrix += '\n'
  }

  // Low Priority (Info)
  const info = []
  Object.values(results.files || {}).forEach(file => {
    file.issues?.forEach(issue => {
      if (issue.severity === 'info') {
        info.push({ ...issue, file: file.path })
      }
    })
  })

  if (info.length > 0) {
    matrix += '#### ğŸ”µ Low Priority (Info)\n\n'
    matrix += '| File | Line | Issue |\n'
    matrix += '|------|------|-------|\n'
    info.slice(0, 10).forEach(issue => {
      const clickableFilePath = `[\`${issue.file.split('/').pop()}\`](${issue.file})`
      matrix += `| ${clickableFilePath} | ${issue.line}:${issue.column} | ${issue.message.substring(0, 60)}... |\n`
    })
    matrix += '\n'
  }

  return matrix
}

function generateFixInstructions() {
  return `### ğŸš¨ Critical Issues (Fix First)
- **Errors (ğŸ”´):** These must be fixed before production deployment
- **Security Issues:** Address immediately to prevent vulnerabilities
- **PWA Issues:** Required for PWA functionality

### âš ï¸ Important Issues (Fix Soon)
- **Warnings (ğŸŸ¡):** These should be addressed in the next development cycle
- **Performance Issues:** Will impact user experience
- **Accessibility Issues:** Required for compliance

### ğŸ’¡ Enhancement Issues (Fix When Possible)
- **Info (ğŸ”µ):** These are suggestions for improvement
- **Code Quality:** Will improve maintainability
- **SEO Optimizations:** Will improve search rankings

### ğŸ› ï¸ General Fix Strategy
1. **Start with Errors** - Fix all critical issues first
2. **Address Warnings** - Fix important issues next
3. **Review Info Items** - Implement improvements when time allows
4. **Re-run Audit** - Verify all issues are resolved
5. **Monitor Regularly** - Run audits during development`
}

function getStatusEmoji(score) {
  if (score >= 90) return 'ğŸŸ¢'
  if (score >= 80) return 'ğŸŸ¡'
  if (score >= 70) return 'ğŸŸ '
  if (score >= 60) return 'ğŸ”´'
  return 'âš«'
}

function getSeverityIcon(severity) {
  switch (severity) {
    case 'error':
      return 'ğŸ”´'
    case 'warning':
      return 'ğŸŸ¡'
    case 'info':
      return 'ğŸ”µ'
    default:
      return 'âšª'
  }
}

function getScoreIcon(score) {
  if (score >= 90) return 'ğŸŸ¢'
  if (score >= 80) return 'ğŸŸ¡'
  if (score >= 70) return 'ğŸŸ '
  if (score >= 60) return 'ğŸ”´'
  return 'âš«'
}
